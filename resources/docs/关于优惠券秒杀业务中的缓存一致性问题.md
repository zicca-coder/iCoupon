### 优惠券秒杀业务
首先在Redis缓存中进行两次判断：
1. 根据用户优惠券领取限制缓存（用户ID+优惠券模板ID作为key，该优惠券模板限制每个用户的领取次数为value）判断是否达到用户领取限制，如果已达到限制则返回，否则继续执行。   
2. 扣减优惠券模板库存是否成功，如果扣减失败表明库存不足，则返回，否则继续执行
两次判断成功，任务用户可以领取优惠券，基于RocketMQ消息生成者发送优惠券领取消息，消息发送成功后主线程返回用户领取成功。

RocketMQ领取优惠券消息消费者获取到消息后，执行以下操作：
1. MySQL数据库层面扣减优惠券模板库存
2. MySQL数据库层面新增用户领取记录
3. Redis缓存中用户领取列表新增优惠券信息。（用户ID为key，ZSET结构存储值，其中用户优惠券记录主键ID-优惠券模板ID作为value，用户领取时间作为score）


### 商家端业务
商家创建优惠券模板：首先在数据库中创建优惠券模板记录，创建成功后在Redis缓存中创建优惠券模板记录，其中优惠券模板的主键ID加前缀作为缓存的key，采用Hash结构存储优惠券模板信息，这样可以单独修改优惠券模板的库存属性。
商家增加优惠券模板库存：首先在数据库中增加优惠券模板库存，然后更新Redis缓存中的优惠券模板库存。


### 问题
假如某个优惠券开启秒杀活动，大量用户请求领取优惠券，与此同时，商家在后管理端增加优惠券库存。如何来保证缓存一致性？有什么比较好的解决方案能够在保证缓存一致性的同时，不会降低用户端领取优惠券的速度？


































